#realize fibonacci  --recursive and dynamic
#recursive one 
def fib(n):
    if n==1 or n==2:
        return 1
    else:
        return fib(n-1)+fib(n-2)
fib(2)

'''
f(n)=f(n-1)+f(n-2)
递归的题目都先写递归的表达式

'''

#2nd method to realize fib
def fib2(n):
    a=1;b=2
    if n==1 or n==2:
        return 1
    #generator 实现？
    for i in range(n-2):
        nn=a+b
        a,b=b,nn
    return nn
#模拟 fib 本身逻辑来 写 ，第二种方法的for循环很实用

# prime num or not?
def is_prime_num(N):
    for i in range(2,N):
        if N%i==0:
            return False
    return True
    


#using deque and dict to realize Gragh and BFS (uncompeleted)
#用双端队列实现 广度优先搜索
#BFS breadth-first search
#创建散列表实现图，python内用字典
from collections import deque

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = [] 
de=deque()
de+=graph['you']
def condition(name):
    if name=="bob":
        return True
    else:
        return False
def BFS(d):
    while not d:
        name = d.popleft()
        if condition(name):
            return name
            break
            
        else:
            d += gragh[name]
    print('nobody')
BFS(de)
